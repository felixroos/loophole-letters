---
title: Making Music with Buffers
description: Getting to the Bottom of Digital Audio
date: "2023-09-02"
tags: ["code"]
---

import { Waveform } from "../../components/scope/Waveform.jsx";
import { ZZFX } from "../../components/zzfx/ZZFX.jsx";
import { BufferPlayer2 } from "../../components/zzfx/BufferPlayer2.jsx";
import { Worklet } from "../../components/worklets/Worklet.jsx";
import { ByteBeat } from "../../components/zzfx/ByteBeat.jsx";

Let's talk about how you can make music with a bunch of numbers!
So far, I've only worked with the Web Audio API nodes, which abstracts the sound synthesis into pluggable objects.
Today I want to go a little deeper and use only the lowest level digital audio synthesis: numbers in a buffer.

## Digital Audio in a nutshell

Sound travels to your ear through air pressure waves.
A loudspeaker is just a very precise pressure wave generator.
If you feed a voltage to a loudspeaker, it will move to a certain position.
When that voltage changes quickly enough, you can make a sound.
In an [analog music system](https://loophole-letters.vercel.app/analog-synthesis), those voltage changes are created directly by something like an oscillator circuit.

In the digital world, the voltage levels for the speaker are generated by the Digital-to-Analog Converter (DAC).
The DAC expects a stream of numbers, which it turns appropriate voltage levels.
Those numbers are typically floating point values between -1 (speaker in), 0 (speaker rests) and 1 (speaker out).

The DAC is eating those numbers at a constant rate, which is called the sample rate.
It is typically around 44100Hz (or 48000Hz), which means a list of 441000 numbers is consumed per second!

Each of those numbers is also called a sample, not to be confused with a sample meaning recorded clip of audio.

## Playing Buffers on the web

It is fairly easy to create and play a buffer on the web, thanks to the Web Audio API:

```js
// we need to wrap everything in a click because of web audio autoplay policy
document.addEventListener("click", () => {
  const ac = new AudioContext();
  // now let's generate a list of numbers
  const seconds = 1;
  let samples = new Float32Array(ac.sampleRate * seconds);

  for (let i = 0; i < samples.length; i++) {
    samples[i] = Math.sin(i / 20) / 5;
  }

  const buffer = ac.createBuffer(1, samples.length, ac.sampleRate);
  const source = ac.createBufferSource();

  buffer.getChannelData(0).set(samples);
  source.buffer = buffer;

  source.connect(ac.destination);
  source.start();
});
```

You can copy the above code and paste it into the browser console, then click somewhere on the page to hear a beatiful sine tone!

The above snippet is mostly boiler plate, the most interesting part is what happens inside the for loop.

To simplify things, here is a text field where you can enter an expression that is evaluated for every sample t:

<BufferPlayer2 value={`sin(t / 10)`} client:only />

You can also play with ctrl+enter!

## Pitches

To get an accurate frequency, we have to calculate it like this:

<BufferPlayer2 value={`sin(220 * t/sampleRate * 2 * pi)`} client:only />

To spare some characters, let's define `s = t/sampleRate` and `c = s * 2 * pi`:

<BufferPlayer2 value={`sin(220 * c)`} client:only />

We can play a major triad like this:

<BufferPlayer2
  value={`sin(330 * c) + sin(440 * c) + sin(550 * c)`}
  client:only
/>

## Waveforms

Sawtooth wave:

<BufferPlayer2 value={`1 - 2 * (220 * s % 1)`} client:only />

Triangle Wave:

<BufferPlayer2 value={`1 - 4 * abs(round(s*220) - s*220)`} client:only />

Square Wave:

<BufferPlayer2 value={`sign(1 - 2 * (220 * s % 1))`} client:only />

Variable Curve:

<BufferPlayer2
  rows={5}
  value={`(()=>{
  let curve = 2;
  let wave = 1 - ((((2*220 * s) % 2) + 2) % 2);
  return sign(wave) * abs(wave) ** curve;
})()`}
  client:only
/>

We can abstract the shapes into functions like this:

```js
const sine = (f) => Math.sin(f * c);
const saw = (f) => 1 - 2 * ((f * s) % 1);
const square = (f) => Math.sign(1 - 2 * ((f * s) % 1));
const tri = (f) => 1 - 4 * Math.abs(Math.round(s * f) - s * f);
```

<BufferPlayer2 value={`tri(220)`} client:only />

## Envelopes

We can add a linear envelope by multiplying with a linear function:

Attack:

<BufferPlayer2 value={`tri(220) * (s<.2 ?s/.2 : 1)`} client:only />

With some conditional logic, we can create a whole ADSR envelope:

<BufferPlayer2
  rows={12}
  seconds={0.5}
  value={`(() => {
    let lerp = (a, b, n) => n * (b - a) + a;
    let attack = .1, decay = .1, sustain = .5, sustainTime = .1, release=.2;
    let gain = 0;
    if(s < attack) {
      gain = s / attack;
    } else if(s < attack + decay) {
      gain = lerp(1, sustain, (s - attack)/decay);
    } else if(s < attack + decay + sustainTime) {
      gain = sustain;
    } else if(s < attack + decay + sustainTime + release) {
      gain = lerp(sustain, 0, (s - attack - decay - sustainTime)/release);
    }
    return tri(220) * gain;
})()`}
  client:only
/>

Let's abstract this into a function:

```js
function adsr(a = 0.001, d = 0.001, sl = 1, st = 0.1, r = 0.001) {
  let ramp = (a, b, n) => n * (b - a) + a;
  let s = t / sr;
  let gain = 0;
  if (s < a) {
    gain = s / a;
  } else if (s < a + d) {
    gain = ramp(1, sl, (s - a) / d);
  } else if (s < a + d + st) {
    gain = sl;
  } else if (s < a + d + st + r) {
    gain = ramp(sl, 0, (s - a - d - st) / r);
  }
  return gain;
}
```

... and use it:

<BufferPlayer2
  seconds={0.5}
  value={`tri(220) * adsr(.1,.1,.5,.1, .1)`}
  client:only
/>

We can abstract it a little more into a variable length line segmentation function:

```js
// api idea from csound
function linsegs(...args) {
  let [v, ...rest] = args;
  let a = 0;
  let lerp = (a, b, n) => n * (b - a) + a;
  while (a < rest.length) {
    const dur = rest[a];
    const next = rest[a + 1];
    if (s < dur) {
      return lerp(v, next, s / dur);
    }
    s -= dur;
    v = next;
    a += 2;
  }
  return args[args.length - 1];
}
```

A simple AD envelope could be written like this:

<BufferPlayer2
  value={`saw(220) * linseg(0,.02,1,.2,0)`}
  seconds={0.3}
  client:only
/>

## Vibrato & FM

<BufferPlayer2 seconds={1} value={`sin(220 * c + sin(c*4)/2)`} client:only />

FM is like vibrato but faster!

<BufferPlayer2 seconds={1} value={`sin(220 * c + sin(c*220)*2)`} client:only />

more bell-like:

<BufferPlayer2 seconds={1} value={`sin(220 * c + sin(c*600)*4)`} client:only />

## Tremolo

<BufferPlayer2 seconds={1} value={`sin(440 * c) *  sin(c*4)`} client:only />

## Writing a tune

We could define multiple notes like this:

<BufferPlayer2
  seconds={3}
  rows={12}
  value={`tri(440) * linseg(0,.0, 0, .01, 1, .1,1,.05,0)
+ tri(440) * linseg(0,.2, 0, .01, 1, .1,1,.05,0)
+ tri(390) * linseg(0,.4, 0, .01, 1, .1, 1,.05,0)
+ tri(440) * linseg(0,.6, 0, .01, 1, .1, 1,.05,0)
+ tri(330) * linseg(0,1, 0, .01, 1, .1, 1,.05,0)
+ tri(330) * linseg(0,1.4, 0, .01, 1, .1, 1,.05,0)
+ tri(440) * linseg(0,1.6, 0, .01, 1, .1, 1,.05,0)
+ tri(586) * linseg(0,1.8, 0, .01, 1, .1, 1,.05,0)
+ tri(550) * linseg(0,2, 0, .01, 1, .1, 1,.05,0)
+ tri(440) * linseg(0,2.2, 0, .01, 1, .1, 1,.05,0)`}
  client:only
/>

Let's write a simple helper for that:

```js
function note(freq, time, duration) {
  return (
    oscillator("triangle", freq) *
    linseg(0, time, 0, 0.01, 1, duration, 1, 0.05, 0)
  );
}
```

<BufferPlayer2
  seconds={3}
  rows={12}
  value={`note(440, .0, .1)
+ note(440, .2, .1)
+ note(390, .4, .1)
+ note(440, .6, .1)
+ note(330, 1, .1)
+ note(330, 1.4, .1)
+ note(440, 1.6, .1)
+ note(586, 1.8, .1)
+ note(550, 2, .1)
+ note(440, 2.2, .1)`}
  client:only
/>

At this point, we could already synthesize something like a midi track with just a bunch of mathematical functions!

I want to make a cut here, but I'll probably dive deeper into this topic.
So far, we've only been pregenerating all the things. It would be very handy if all of this could run in real time, using AudioWorklets.
I am also curious if I can reimplement ZZFX as an AudioWorklet.
Until next time!
