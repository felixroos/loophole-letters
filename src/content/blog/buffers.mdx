---
title: Making Music with Buffers
description: Getting to the Bottom of Digital Audio
date: "2023-09-02"
tags: ["code"]
draft: true
---

import { Waveform } from "../../components/scope/Waveform.jsx";
import { ZZFX } from "../../components/zzfx/ZZFX.jsx";
import { BufferPlayer2 } from "../../components/zzfx/BufferPlayer2.jsx";
import { Worklet } from "../../components/worklets/Worklet.jsx";
import { ByteBeat } from "../../components/zzfx/ByteBeat.jsx";

Let's talk about how you can make music with a bunch of numbers!

## Digital Audio in a nutshell

Sound travels to your ear through air pressure waves.
A loudspeaker is just a very precise pressure wave generator.
If you feed a voltage to a loudspeaker, it will move to a certain position.
When that voltage changes quickly enough, you can make a sound.
In an [analog music system](https://loophole-letters.vercel.app/analog-synthesis), those voltage changes are created directly by something like an oscillator circuit.

In the digital world, the voltage levels for the speaker are generated by the Digital-to-Analog Converter (DAC).
The DAC expects a stream of numbers, which it turns appropriate voltage levels.
Those numbers are typically floating point values between -1 (speaker in), 0 (speaker rests) and 1 (speaker out).

The DAC is eating those numbers at a constant rate, which is called the sample rate.
It is typically around 44100Hz (or 48000Hz), which means a list of 441000 numbers is consumed per second!

Each of those numbers is also called a sample, not to be confused with a sample meaning recorded clip of audio.

## Playing Buffers on the web

It is fairly easy to create and play a buffer on the web, thanks to the Web Audio API:

```js
// we need to wrap everything in a click because of web audio autoplay policy
document.addEventListener("click", () => {
  const ac = new AudioContext();
  // now let's generate a list of numbers
  const seconds = 1;
  let samples = new Float32Array(ac.sampleRate * seconds);

  for (let i = 0; i < samples.length; i++) {
    samples[i] = Math.sin(i / 20) / 5;
  }

  const buffer = ac.createBuffer(1, samples.length, ac.sampleRate);
  const source = ac.createBufferSource();

  buffer.getChannelData(0).set(samples);
  source.buffer = buffer;

  source.connect(ac.destination);
  source.start();
});
```

You can copy the above code and paste it into the browser console, then click somewhere on the page to hear a beatiful sine tone!

The above snippet is mostly boiler plate, the most interesting part is what happens inside the for loop.

To simplify things, here is a text field where you can enter an expression that is evaluated for every sample t:

<BufferPlayer2 value={`sin(t / 10)`} client:only />

You can also play with ctrl+enter!

## Pitches

To get an accurate frequency, we have to calculate it like this:

<BufferPlayer2 value={`sin(220 * t/sampleRate * 2 * pi)`} client:only />

To spare some characters, let's define `s = t/sampleRate` and `c = s * 2 * pi`:

<BufferPlayer2 value={`sin(220 * c)`} client:only />

We can play a major triad like this:

<BufferPlayer2
  value={`sin(330 * c) + sin(440 * c) + sin(550 * c)`}
  client:only
/>

## Waveforms

Sawtooth wave:

<BufferPlayer2 value={`1 - 2 * (220 * s % 1)`} client:only />

Triangle Wave:

<BufferPlayer2 value={`1 - 4 * abs(round(s*220) - s*220)`} client:only />

Square Wave:

<BufferPlayer2 value={`sign(1 - 2 * (220 * s % 1))`} client:only />

Variable Curve:

<BufferPlayer2
  rows={5}
  value={`(()=>{
  let curve = 2;
  let wave = 1 - ((((2*220 * s) % 2) + 2) % 2);
  return sign(wave) * abs(wave) ** curve;
})()`}
  client:only
/>

We can abstract the shapes into functions like this:

```js
const sine = (f) => Math.sin(f * c);
const saw = (f) => 1 - 2 * ((f * s) % 1);
const square = (f) => Math.sign(1 - 2 * ((f * s) % 1));
const tri = (f) => 1 - 4 * Math.abs(Math.round(s * f) - s * f);
```

<BufferPlayer2 value={`saw(220)`} client:only />

## Envelopes

Attack:

<BufferPlayer2 value={`saw(220) * (s<.2 ?s/.2 : 1)`} client:only />

Decay:

<BufferPlayer2
  value={`saw(220) * (s<.1 ? 1 : s<.2 ? 1-(s-.1)/.1 : 0)`}
  client:only
/>

Attack + Decay:

<BufferPlayer2
  value={`saw(220) * (s<.1 ?s/.1 : 1) * (s<.1 ? 1 : s<.2 ? 1-(s-.1)/.1 : 0)`}
  client:only
/>

## Vibrato & FM

<BufferPlayer2 seconds={2} value={`sin(220 * c + sin(c*4)/2 )`} client:only />

FM is like vibrato but faster!

<BufferPlayer2 seconds={2} value={`sin(220 * c + sin(c*220)*2 )`} client:only />

more bell-like:

<BufferPlayer2 seconds={2} value={`sin(220 * c + sin(c*600)*4)`} client:only />

## Tremolo

<BufferPlayer2 seconds={2} value={`sin(440 * c) *  sin(c*4)`} client:only />
